0 = drain


drainの条件
引き算
多分最初に差分を求める
一番端っこは漏れるから例外

import numpy as np

(m, n)

前提: 3*3 is minimum

前提：ブロックの数
if m>2, n>2:

3次元にするmax(value)
ワンホットベクトル化する(3, 3)
max(value) * m*n の2Dに展開(あとでm*nに戻す)

[[1,3,4]
 [0,0,1]
 [1,1,1]] 最大値4はZ次元候補になる

[1,3,4,3,0,0,1,1,1,1]

前提8以上1がないと0を囲えない

Zを得る Z=z最初は
[1,1,1,1,0,0,1,1,1,1]
[1,1,1,1,0,0,1,1,1,1]
[1,1,1,1,0,0,1,1,1,1]
[1,0,1,0,0,0,1,1,1,1]この時点で1が8以上ないzi行Zがあればzの次元数のZ


reshape(Z, m, n)する

[[1,1,1]
 [0,0,1]
 [1,1,1]]

[[0,1,1]
 [0,0,0]
 [0,0,0]]

[[0,1,1]
 [0,0,0]
 [0,0,0]]

[[0,0,1]
 [0,0,0]
 [0,0,0]]

 [[1,3,4]
  [0,0,1]
  [1,1,1]]


まず0が存在しない
最大値が2以上
2以上が8以上ある

3次元にreshape(最大値+1, m, n)
for z in range(1, n+1)
if valueの足し算sumが8以上内なら続行
満たさないziが出た時点で(zi-1, m, n)

for value 0 in マトリクス[1:n-1][1:n-1]
0のindexは[x,y]とする[m,n]
0のx_list, y_listを2つの[]に格納し, iでループindexがあるからok

まずは水平方向のブロックから,
もしx固定でn[0:y]に1が1つ以上あれば続行
さらにもしn[y+1:m]に1が1つ以上あれば続行

また垂直方向のブロックから,
もしy固定でm[0:x]に1が1つ以上あれば続行
さらにもしn[y+1:m]に1が1つ以上あれば続行

全クリで初めて1ブロック分水がある
これをぜんvalue0のインデックスでループする

counter for 水入りブロック
条件を満たすcounterが1store以上の時continueする
counter >= 1: かつネクストのvalueの足し算sumが8以上内なら続行
そうでなければループストップ

counter * 1 = 水の数
